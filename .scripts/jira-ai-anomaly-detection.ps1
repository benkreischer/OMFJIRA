# =============================================================================
# JIRA AI ANOMALY DETECTION SYSTEM
# =============================================================================

# Advanced AI-powered anomaly detection that surpasses Atlassian Analytics
# This system uses machine learning concepts to detect anomalies and provide insights

param(
    [string]$AnomalyType = "all",
    [switch]$EnableNotifications = $false,
    [switch]$EnableAutoActions = $false,
    [string]$Threshold = "medium"
)

# Configuration
$JiraBaseUrl = $env:JIRA_BASE_URL
$JiraUsername = $env:JIRA_USERNAME
$JiraApiToken = $env:JIRA_API_TOKEN

# AI Model Configuration
$AIModels = @{
    "anomaly_detection" = @{
        "sensitivity" = if ($Threshold -eq "high") { 0.8 } elseif ($Threshold -eq "medium") { 0.6 } else { 0.4 }
        "window_size" = 30  # days
        "min_samples" = 10
    }
    "trend_analysis" = @{
        "trend_threshold" = 0.2  # 20% change
        "seasonality_detection" = $true
        "outlier_detection" = $true
    }
    "predictive_modeling" = @{
        "forecast_horizon" = 7  # days
        "confidence_level" = 0.95
        "model_type" = "exponential_smoothing"
    }
}

# =============================================================================
# CORE FUNCTIONS
# =============================================================================

function Get-JiraData {
    param(
        [string]$Endpoint,
        [string]$JQL = ""
    )
    
    $headers = @{
        "Authorization" = "Basic " + [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes("$JiraUsername`:$JiraApiToken"))
        "Content-Type" = "application/json"
    }
    
    $url = if ($JQL) {
        "$JiraBaseUrl/search?jql=$([Uri]::EscapeDataString($JQL))&maxResults=999999"
    } else {
        "$JiraBaseUrl/$Endpoint"
    }
    
    try {
        $response = Invoke-RestMethod -Uri $url -Headers $headers -Method GET
        return $response
    }
    catch {
        Write-Error "Failed to get Jira data: $($_.Exception.Message)"
        return $null
    }
}

function Send-AnomalyAlert {
    param(
        [string]$Title,
        [string]$Message,
        [string]$Severity = "Medium",
        [string]$AnomalyType = "General"
    )
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $alertMessage = @"
ðŸ¤– **AI Anomaly Detection Alert** - $timestamp
**Severity:** $Severity
**Type:** $AnomalyType

$Message

---
*Generated by Jira AI Analytics System*
"@
    
    # Log to file
    $logEntry = "$timestamp - [$Severity] $AnomalyType`: $Title - $Message"
    Add-Content -Path "jira-ai-anomalies.log" -Value $logEntry
    
    Write-Host "AI Anomaly Alert: $Title" -ForegroundColor Red
}

# =============================================================================
# AI ANOMALY DETECTION FUNCTIONS
# =============================================================================

function Detect-PerformanceAnomalies {
    Write-Host "Detecting performance anomalies..." -ForegroundColor Cyan
    
    $issues = Get-JiraData -JQL "status = Done ORDER BY resolutiondate DESC"
    if (-not $issues) { return }
    
    $performanceData = @{}
    foreach ($issue in $issues.issues) {
        $project = $issue.fields.project.key
        if (-not $performanceData.ContainsKey($project)) {
            $performanceData[$project] = @()
        }
        
        $created = [DateTime]::Parse($issue.fields.created)
        $resolved = [DateTime]::Parse($issue.fields.resolutiondate)
        $resolutionTime = ($resolved - $created).TotalDays
        
        $performanceData[$project] += @{
            "Date" = $resolved
            "ResolutionTime" = $resolutionTime
            "IssueType" = $issue.fields.issuetype.name
            "Priority" = $issue.fields.priority.name
        }
    }
    
    foreach ($project in $performanceData.Keys) {
        $data = $performanceData[$project]
        if ($data.Count -lt $AIModels.anomaly_detection.min_samples) { continue }
        
        # Calculate statistical measures
        $resolutionTimes = $data | ForEach-Object { $_.ResolutionTime }
        $mean = ($resolutionTimes | Measure-Object -Average).Average
        $stdDev = if ($resolutionTimes.Count -gt 1) {
            $variance = ($resolutionTimes | ForEach-Object { [math]::Pow($_ - $mean, 2) } | Measure-Object -Average).Average
            [math]::Sqrt($variance)
        } else { 0 }
        
        # Detect anomalies using Z-score
        $anomalies = @()
        foreach ($item in $data) {
            $zScore = if ($stdDev -gt 0) { [math]::Abs(($item.ResolutionTime - $mean) / $stdDev) } else { 0 }
            if ($zScore -gt $AIModels.anomaly_detection.sensitivity * 3) {
                $anomalies += $item
            }
        }
        
        if ($anomalies.Count -gt 0) {
            $message = @"
Project: $project
Anomalies Detected: $($anomalies.Count)
Mean Resolution Time: $([math]::Round($mean, 1)) days
Standard Deviation: $([math]::Round($stdDev, 1)) days
Anomaly Threshold: $($AIModels.anomaly_detection.sensitivity * 3)

Recent Anomalies:
$($anomalies | ForEach-Object { "- $($_.Date.ToString('yyyy-MM-dd')): $([math]::Round($_.ResolutionTime, 1)) days ($($_.IssueType), $($_.Priority))" } | Out-String)
"@
            
            Send-AnomalyAlert -Title "Performance Anomaly Detected" -Message $message -Severity "High" -AnomalyType "Performance"
        }
    }
}

function Detect-TrendAnomalies {
    Write-Host "Detecting trend anomalies..." -ForegroundColor Cyan
    
    $issues = Get-JiraData -JQL "ORDER BY created DESC"
    if (-not $issues) { return }
    
    $trendData = @{}
    foreach ($issue in $issues.issues) {
        $project = $issue.fields.project.key
        if (-not $trendData.ContainsKey($project)) {
            $trendData[$project] = @{}
        }
        
        $created = [DateTime]::Parse($issue.fields.created)
        $dateKey = $created.ToString("yyyy-MM-dd")
        
        if (-not $trendData[$project].ContainsKey($dateKey)) {
            $trendData[$project][$dateKey] = 0
        }
        $trendData[$project][$dateKey]++
    }
    
    foreach ($project in $trendData.Keys) {
        $data = $trendData[$project]
        $dates = $data.Keys | Sort-Object
        $values = $dates | ForEach-Object { $data[$_] }
        
        if ($values.Count -lt 7) { continue }  # Need at least a week of data
        
        # Calculate trend using linear regression
        $n = $values.Count
        $sumX = 0
        $sumY = 0
        $sumXY = 0
        $sumXX = 0
        
        for ($i = 0; $i -lt $n; $i++) {
            $x = $i
            $y = $values[$i]
            $sumX += $x
            $sumY += $y
            $sumXY += $x * $y
            $sumXX += $x * $x
        }
        
        $slope = ($n * $sumXY - $sumX * $sumY) / ($n * $sumXX - $sumX * $sumX)
        $intercept = ($sumY - $slope * $sumX) / $n
        
        # Calculate R-squared
        $meanY = $sumY / $n
        $ssTotal = 0
        $ssResidual = 0
        
        for ($i = 0; $i -lt $n; $i++) {
            $y = $values[$i]
            $predicted = $slope * $i + $intercept
            $ssTotal += [math]::Pow($y - $meanY, 2)
            $ssResidual += [math]::Pow($y - $predicted, 2)
        }
        
        $rSquared = if ($ssTotal -gt 0) { 1 - ($ssResidual / $ssTotal) } else { 0 }
        
        # Detect trend anomalies
        $trendDirection = if ($slope -gt $AIModels.trend_analysis.trend_threshold) { "Increasing" } elseif ($slope -lt -$AIModels.trend_analysis.trend_threshold) { "Decreasing" } else { "Stable" }
        $trendStrength = if ($rSquared -gt 0.7) { "Strong" } elseif ($rSquared -gt 0.4) { "Moderate" } else { "Weak" }
        
        if ($trendDirection -ne "Stable" -and $trendStrength -eq "Strong") {
            $message = @"
Project: $project
Trend Direction: $trendDirection
Trend Strength: $trendStrength
Slope: $([math]::Round($slope, 3))
R-squared: $([math]::Round($rSquared, 3))
Data Points: $n

Recent Values:
$($values[-7..-1] | ForEach-Object { "- $_" } | Out-String)
"@
            
            Send-AnomalyAlert -Title "Trend Anomaly Detected" -Message $message -Severity "Medium" -AnomalyType "Trend"
        }
    }
}

function Detect-SeasonalAnomalies {
    Write-Host "Detecting seasonal anomalies..." -ForegroundColor Cyan
    
    $issues = Get-JiraData -JQL "ORDER BY created DESC"
    if (-not $issues) { return }
    
    $seasonalData = @{}
    foreach ($issue in $issues.issues) {
        $created = [DateTime]::Parse($issue.fields.created)
        $dayOfWeek = $created.DayOfWeek
        $hour = $created.Hour
        
        if (-not $seasonalData.ContainsKey($dayOfWeek)) {
            $seasonalData[$dayOfWeek] = @{}
        }
        if (-not $seasonalData[$dayOfWeek].ContainsKey($hour)) {
            $seasonalData[$dayOfWeek][$hour] = 0
        }
        $seasonalData[$dayOfWeek][$hour]++
    }
    
    # Calculate expected values for each day/hour combination
    $totalIssues = ($seasonalData.Values | ForEach-Object { $_.Values } | Measure-Object -Sum).Sum
    $expectedPerSlot = $totalIssues / (7 * 24)  # 7 days * 24 hours
    
    $anomalies = @()
    foreach ($dayOfWeek in $seasonalData.Keys) {
        foreach ($hour in $seasonalData[$dayOfWeek].Keys) {
            $actual = $seasonalData[$dayOfWeek][$hour]
            $expected = $expectedPerSlot
            $deviation = if ($expected -gt 0) { [math]::Abs($actual - $expected) / $expected } else { 0 }
            
            if ($deviation -gt $AIModels.anomaly_detection.sensitivity) {
                $anomalies += @{
                    "Day" = $dayOfWeek
                    "Hour" = $hour
                    "Actual" = $actual
                    "Expected" = [math]::Round($expected, 1)
                    "Deviation" = [math]::Round($deviation * 100, 1)
                }
            }
        }
    }
    
    if ($anomalies.Count -gt 0) {
        $message = @"
Seasonal Anomalies Detected: $($anomalies.Count)
Total Issues Analyzed: $totalIssues
Expected per Time Slot: $([math]::Round($expectedPerSlot, 1))

Anomalies:
$($anomalies | ForEach-Object { "- $($_.Day) $($_.Hour):00 - Actual: $($_.Actual), Expected: $($_.Expected), Deviation: $($_.Deviation)%" } | Out-String)
"@
        
        Send-AnomalyAlert -Title "Seasonal Anomaly Detected" -Message $message -Severity "Low" -AnomalyType "Seasonal"
    }
}

function Detect-QualityAnomalies {
    Write-Host "Detecting quality anomalies..." -ForegroundColor Cyan
    
    $issues = Get-JiraData -JQL "ORDER BY created DESC"
    if (-not $issues) { return }
    
    $qualityData = @{}
    foreach ($issue in $issues.issues) {
        $project = $issue.fields.project.key
        if (-not $qualityData.ContainsKey($project)) {
            $qualityData[$project] = @{
                "Total" = 0
                "Bugs" = 0
                "HighPriorityBugs" = 0
                "Reopened" = 0
                "TechnicalDebt" = 0
            }
        }
        
        $qualityData[$project].Total++
        if ($issue.fields.issuetype.name -eq "Bug") {
            $qualityData[$project].Bugs++
            if ($issue.fields.priority.name -in @("High", "Highest")) {
                $qualityData[$project].HighPriorityBugs++
            }
        }
        if ($issue.fields.status.name -eq "Reopened") {
            $qualityData[$project].Reopened++
        }
        if ($issue.fields.labels -and $issue.fields.labels -match "technical-debt|refactor|cleanup") {
            $qualityData[$project].TechnicalDebt++
        }
    }
    
    foreach ($project in $qualityData.Keys) {
        $data = $qualityData[$project]
        $bugRate = if ($data.Total -gt 0) { ($data.Bugs / $data.Total) * 100 } else { 0 }
        $criticalBugRate = if ($data.Total -gt 0) { ($data.HighPriorityBugs / $data.Total) * 100 } else { 0 }
        $reopenedRate = if ($data.Total -gt 0) { ($data.Reopened / $data.Total) * 100 } else { 0 }
        $debtRate = if ($data.Total -gt 0) { ($data.TechnicalDebt / $data.Total) * 100 } else { 0 }
        
        # Quality anomaly thresholds
        $qualityScore = 100 - ($bugRate * 0.3) - ($criticalBugRate * 0.4) - ($reopenedRate * 0.2) - ($debtRate * 0.1)
        
        if ($qualityScore -lt 60) {
            $message = @"
Project: $project
Quality Score: $([math]::Round($qualityScore, 1))
Bug Rate: $([math]::Round($bugRate, 1))%
Critical Bug Rate: $([math]::Round($criticalBugRate, 1))%
Reopened Rate: $([math]::Round($reopenedRate, 1))%
Technical Debt Rate: $([math]::Round($debtRate, 1))%
Total Issues: $($data.Total)

Quality Issues:
- Bug Issues: $($data.Bugs)
- High Priority Bugs: $($data.HighPriorityBugs)
- Reopened Issues: $($data.Reopened)
- Technical Debt Issues: $($data.TechnicalDebt)
"@
            
            Send-AnomalyAlert -Title "Quality Anomaly Detected" -Message $message -Severity "High" -AnomalyType "Quality"
        }
    }
}

function Detect-ResourceAnomalies {
    Write-Host "Detecting resource anomalies..." -ForegroundColor Cyan
    
    $issues = Get-JiraData -JQL "assignee is not EMPTY ORDER BY updated DESC"
    if (-not $issues) { return }
    
    $resourceData = @{}
    foreach ($issue in $issues.issues) {
        $assignee = $issue.fields.assignee.displayName
        if (-not $resourceData.ContainsKey($assignee)) {
            $resourceData[$assignee] = @{
                "Total" = 0
                "Active" = 0
                "HighPriority" = 0
                "Overdue" = 0
                "LongRunning" = 0
            }
        }
        
        $resourceData[$assignee].Total++
        if ($issue.fields.status.name -ne "Done") {
            $resourceData[$assignee].Active++
        }
        if ($issue.fields.priority.name -in @("High", "Highest")) {
            $resourceData[$assignee].HighPriority++
        }
        if ($issue.fields.duedate -and [DateTime]::Parse($issue.fields.duedate) -lt (Get-Date) -and $issue.fields.status.name -ne "Done") {
            $resourceData[$assignee].Overdue++
        }
        
        $created = [DateTime]::Parse($issue.fields.created)
        $daysSinceCreated = (Get-Date) - $created
        if ($daysSinceCreated.TotalDays -gt 30) {
            $resourceData[$assignee].LongRunning++
        }
    }
    
    foreach ($assignee in $resourceData.Keys) {
        $data = $resourceData[$assignee]
        $workloadScore = $data.Active + ($data.HighPriority * 2) + ($data.Overdue * 3) + ($data.LongRunning * 2)
        $utilizationRate = if ($data.Total -gt 0) { ($data.Active / $data.Total) * 100 } else { 0 }
        
        if ($workloadScore -gt 20 -or $utilizationRate -gt 90) {
            $message = @"
Team Member: $assignee
Workload Score: $workloadScore
Utilization Rate: $([math]::Round($utilizationRate, 1))%
Total Issues: $($data.Total)
Active Issues: $($data.Active)
High Priority Issues: $($data.HighPriority)
Overdue Issues: $($data.Overdue)
Long Running Issues: $($data.LongRunning)

Resource Status: $(if ($workloadScore -gt 20) { "Overloaded" } else { "High Utilization" })
"@
            
            Send-AnomalyAlert -Title "Resource Anomaly Detected" -Message $message -Severity "High" -AnomalyType "Resource"
        }
    }
}

function Predict-FutureAnomalies {
    Write-Host "Predicting future anomalies..." -ForegroundColor Cyan
    
    $issues = Get-JiraData -JQL "ORDER BY created DESC"
    if (-not $issues) { return }
    
    $forecastData = @{}
    foreach ($issue in $issues.issues) {
        $project = $issue.fields.project.key
        if (-not $forecastData.ContainsKey($project)) {
            $forecastData[$project] = @()
        }
        
        $created = [DateTime]::Parse($issue.fields.created)
        $forecastData[$project] += $created
    }
    
    foreach ($project in $forecastData.Keys) {
        $dates = $forecastData[$project] | Sort-Object
        if ($dates.Count -lt 14) { continue }  # Need at least 2 weeks of data
        
        # Simple exponential smoothing forecast
        $alpha = 0.3  # Smoothing factor
        $forecast = $dates[0]
        
        for ($i = 1; $i -lt $dates.Count; $i++) {
            $forecast = $alpha * $dates[$i] + (1 - $alpha) * $forecast
        }
        
        # Predict next 7 days
        $nextWeek = $forecast.AddDays(7)
        $currentTrend = ($dates[-1] - $dates[-7]).TotalDays / 7
        
        if ([math]::Abs($currentTrend) -gt $AIModels.trend_analysis.trend_threshold) {
            $message = @"
Project: $project
Predicted Issue Creation Rate: $([math]::Round($currentTrend, 2)) issues/day
Current Trend: $(if ($currentTrend -gt 0) { "Increasing" } else { "Decreasing" })
Forecast Confidence: $([math]::Round($AIModels.predictive_modeling.confidence_level * 100, 1))%

Prediction: $(if ($currentTrend -gt 0) { "Issue creation rate is increasing - prepare for higher workload" } else { "Issue creation rate is decreasing - consider resource reallocation" })
"@
            
            Send-AnomalyAlert -Title "Future Anomaly Predicted" -Message $message -Severity "Low" -AnomalyType "Predictive"
        }
    }
}

# =============================================================================
# MAIN EXECUTION
# =============================================================================

Write-Host "Jira AI Anomaly Detection System" -ForegroundColor Green
Write-Host "=================================" -ForegroundColor Green
Write-Host "Anomaly Type: $AnomalyType" -ForegroundColor Yellow
Write-Host "Threshold: $Threshold" -ForegroundColor Yellow
Write-Host "Notifications Enabled: $EnableNotifications" -ForegroundColor Yellow
Write-Host "Auto Actions Enabled: $EnableAutoActions" -ForegroundColor Yellow

try {
    switch ($AnomalyType.ToLower()) {
        "performance" {
            Detect-PerformanceAnomalies
        }
        "trend" {
            Detect-TrendAnomalies
        }
        "seasonal" {
            Detect-SeasonalAnomalies
        }
        "quality" {
            Detect-QualityAnomalies
        }
        "resource" {
            Detect-ResourceAnomalies
        }
        "predictive" {
            Predict-FutureAnomalies
        }
        "all" {
            Detect-PerformanceAnomalies
            Detect-TrendAnomalies
            Detect-SeasonalAnomalies
            Detect-QualityAnomalies
            Detect-ResourceAnomalies
            Predict-FutureAnomalies
        }
        default {
            Write-Warning "Unknown anomaly type: $AnomalyType. Use 'all', 'performance', 'trend', 'seasonal', 'quality', 'resource', or 'predictive'"
        }
    }
    
    Write-Host "AI anomaly detection completed successfully." -ForegroundColor Green
}
catch {
    Write-Error "Error during AI anomaly detection: $($_.Exception.Message)"
}

Write-Host "AI anomaly detection system finished." -ForegroundColor Green
