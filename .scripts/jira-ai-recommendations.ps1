# =============================================================================
# JIRA AI RECOMMENDATIONS ENGINE
# =============================================================================

# Advanced AI-powered recommendations system that surpasses Atlassian Analytics
# This system provides intelligent insights and actionable recommendations

param(
    [string]$RecommendationType = "all",
    [switch]$EnableNotifications = $false,
    [switch]$EnableAutoActions = $false,
    [string]$Priority = "medium"
)

# Configuration
$JiraBaseUrl = $env:JIRA_BASE_URL
$JiraUsername = $env:JIRA_USERNAME
$JiraApiToken = $env:JIRA_API_TOKEN

# AI Recommendation Engine Configuration
$RecommendationEngine = @{
    "performance_optimization" = @{
        "enabled" = $true
        "threshold" = 0.7
        "confidence_level" = 0.8
    }
    "resource_optimization" = @{
        "enabled" = $true
        "threshold" = 0.6
        "confidence_level" = 0.75
    }
    "quality_improvement" = @{
        "enabled" = $true
        "threshold" = 0.8
        "confidence_level" = 0.85
    }
    "process_optimization" = @{
        "enabled" = $true
        "threshold" = 0.65
        "confidence_level" = 0.7
    }
    "risk_mitigation" = @{
        "enabled" = $true
        "threshold" = 0.9
        "confidence_level" = 0.9
    }
}

# =============================================================================
# CORE FUNCTIONS
# =============================================================================

function Get-JiraData {
    param(
        [string]$Endpoint,
        [string]$JQL = ""
    )
    
    $headers = @{
        "Authorization" = "Basic " + [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes("$JiraUsername`:$JiraApiToken"))
        "Content-Type" = "application/json"
    }
    
    $url = if ($JQL) {
        "$JiraBaseUrl/search?jql=$([Uri]::EscapeDataString($JQL))&maxResults=999999"
    } else {
        "$JiraBaseUrl/$Endpoint"
    }
    
    try {
        $response = Invoke-RestMethod -Uri $url -Headers $headers -Method GET
        return $response
    }
    catch {
        Write-Error "Failed to get Jira data: $($_.Exception.Message)"
        return $null
    }
}

function Send-Recommendation {
    param(
        [string]$Title,
        [string]$Recommendation,
        [string]$Impact = "Medium",
        [string]$Effort = "Medium",
        [string]$Category = "General"
    )
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $recommendationMessage = @"
ðŸ’¡ **AI Recommendation** - $timestamp
**Category:** $Category
**Impact:** $Impact
**Effort:** $Effort

$Recommendation

---
*Generated by Jira AI Recommendations Engine*
"@
    
    # Log to file
    $logEntry = "$timestamp - [$Category] $Title - Impact: $Impact, Effort: $Effort"
    Add-Content -Path "jira-ai-recommendations.log" -Value $logEntry
    
    Write-Host "AI Recommendation: $Title" -ForegroundColor Green
}

# =============================================================================
# AI RECOMMENDATION FUNCTIONS
# =============================================================================

function Get-PerformanceOptimizationRecommendations {
    Write-Host "Generating performance optimization recommendations..." -ForegroundColor Cyan
    
    $issues = Get-JiraData -JQL "status = Done ORDER BY resolutiondate DESC"
    if (-not $issues) { return }
    
    $performanceData = @{}
    foreach ($issue in $issues.issues) {
        $project = $issue.fields.project.key
        if (-not $performanceData.ContainsKey($project)) {
            $performanceData[$project] = @{
                "Total" = 0
                "ResolutionTimes" = @()
                "IssueTypes" = @{}
                "Priorities" = @{}
            }
        }
        
        $created = [DateTime]::Parse($issue.fields.created)
        $resolved = [DateTime]::Parse($issue.fields.resolutiondate)
        $resolutionTime = ($resolved - $created).TotalDays
        
        $performanceData[$project].Total++
        $performanceData[$project].ResolutionTimes += $resolutionTime
        
        $issueType = $issue.fields.issuetype.name
        if (-not $performanceData[$project].IssueTypes.ContainsKey($issueType)) {
            $performanceData[$project].IssueTypes[$issueType] = 0
        }
        $performanceData[$project].IssueTypes[$issueType]++
        
        $priority = $issue.fields.priority.name
        if (-not $performanceData[$project].Priorities.ContainsKey($priority)) {
            $performanceData[$project].Priorities[$priority] = 0
        }
        $performanceData[$project].Priorities[$priority]++
    }
    
    foreach ($project in $performanceData.Keys) {
        $data = $performanceData[$project]
        $avgResolutionTime = ($data.ResolutionTimes | Measure-Object -Average).Average
        $medianResolutionTime = ($data.ResolutionTimes | Sort-Object)[[math]::Floor($data.ResolutionTimes.Count / 2)]
        $stdDev = if ($data.ResolutionTimes.Count -gt 1) {
            $variance = ($data.ResolutionTimes | ForEach-Object { [math]::Pow($_ - $avgResolutionTime, 2) } | Measure-Object -Average).Average
            [math]::Sqrt($variance)
        } else { 0 }
        
        # Generate recommendations based on performance metrics
        $recommendations = @()
        
        if ($avgResolutionTime -gt 14) {
            $recommendations += "Consider breaking down large issues into smaller, more manageable tasks. Current average resolution time is $([math]::Round($avgResolutionTime, 1)) days, which exceeds the recommended 14-day threshold."
        }
        
        if ($stdDev -gt 10) {
            $recommendations += "High variability in resolution times ($([math]::Round($stdDev, 1)) days standard deviation) suggests inconsistent processes. Implement standardized workflows and clear acceptance criteria."
        }
        
        # Analyze issue type performance
        $slowestIssueType = ($data.IssueTypes.GetEnumerator() | Sort-Object Value -Descending | Select-Object -First 1)
        if ($slowestIssueType -and $slowestIssueType.Value -gt $data.Total * 0.3) {
            $recommendations += "Focus on optimizing $($slowestIssueType.Key) issues, which represent $([math]::Round(($slowestIssueType.Value / $data.Total) * 100, 1))% of total issues."
        }
        
        if ($recommendations.Count -gt 0) {
            $recommendation = $recommendations -join "`n`n"
            Send-Recommendation -Title "Performance Optimization for $project" -Recommendation $recommendation -Impact "High" -Effort "Medium" -Category "Performance"
        }
    }
}

function Get-ResourceOptimizationRecommendations {
    Write-Host "Generating resource optimization recommendations..." -ForegroundColor Cyan
    
    $issues = Get-JiraData -JQL "assignee is not EMPTY ORDER BY updated DESC"
    if (-not $issues) { return }
    
    $resourceData = @{}
    foreach ($issue in $issues.issues) {
        $assignee = $issue.fields.assignee.displayName
        if (-not $resourceData.ContainsKey($assignee)) {
            $resourceData[$assignee] = @{
                "Total" = 0
                "Active" = 0
                "Completed" = 0
                "HighPriority" = 0
                "Overdue" = 0
                "Skills" = @{}
                "Projects" = @{}
            }
        }
        
        $resourceData[$assignee].Total++
        if ($issue.fields.status.name -eq "Done") {
            $resourceData[$assignee].Completed++
        } else {
            $resourceData[$assignee].Active++
        }
        if ($issue.fields.priority.name -in @("High", "Highest")) {
            $resourceData[$assignee].HighPriority++
        }
        if ($issue.fields.duedate -and [DateTime]::Parse($issue.fields.duedate) -lt (Get-Date) -and $issue.fields.status.name -ne "Done") {
            $resourceData[$assignee].Overdue++
        }
        
        $issueType = $issue.fields.issuetype.name
        if (-not $resourceData[$assignee].Skills.ContainsKey($issueType)) {
            $resourceData[$assignee].Skills[$issueType] = 0
        }
        $resourceData[$assignee].Skills[$issueType]++
        
        $project = $issue.fields.project.key
        if (-not $resourceData[$assignee].Projects.ContainsKey($project)) {
            $resourceData[$assignee].Projects[$project] = 0
        }
        $resourceData[$assignee].Projects[$project]++
    }
    
    foreach ($assignee in $resourceData.Keys) {
        $data = $resourceData[$assignee]
        $completionRate = if ($data.Total -gt 0) { ($data.Completed / $data.Total) * 100 } else { 0 }
        $utilizationRate = if ($data.Total -gt 0) { ($data.Active / $data.Total) * 100 } else { 0 }
        $overdueRate = if ($data.Total -gt 0) { ($data.Overdue / $data.Total) * 100 } else { 0 }
        
        $recommendations = @()
        
        if ($utilizationRate -gt 90) {
            $recommendations += "High utilization rate ($([math]::Round($utilizationRate, 1))%) indicates potential burnout risk. Consider redistributing workload or providing additional support."
        }
        
        if ($overdueRate -gt 20) {
            $recommendations += "High overdue rate ($([math]::Round($overdueRate, 1))%) suggests capacity issues. Review workload and deadline management."
        }
        
        if ($completionRate -lt 60) {
            $recommendations += "Low completion rate ($([math]::Round($completionRate, 1))%) may indicate skill gaps or process inefficiencies. Consider training or mentoring."
        }
        
        # Analyze skill distribution
        $primarySkill = ($data.Skills.GetEnumerator() | Sort-Object Value -Descending | Select-Object -First 1)
        if ($primarySkill -and $primarySkill.Value -gt $data.Total * 0.7) {
            $recommendations += "Over-specialization in $($primarySkill.Key) ($([math]::Round(($primarySkill.Value / $data.Total) * 100, 1))% of work). Consider cross-training to increase flexibility."
        }
        
        # Analyze project distribution
        $projectCount = $data.Projects.Count
        if ($projectCount -gt 5) {
            $recommendations += "Working on $projectCount different projects may cause context switching overhead. Consider consolidating to 2-3 projects maximum."
        }
        
        if ($recommendations.Count -gt 0) {
            $recommendation = $recommendations -join "`n`n"
            Send-Recommendation -Title "Resource Optimization for $assignee" -Recommendation $recommendation -Impact "Medium" -Effort "Low" -Category "Resource"
        }
    }
}

function Get-QualityImprovementRecommendations {
    Write-Host "Generating quality improvement recommendations..." -ForegroundColor Cyan
    
    $issues = Get-JiraData -JQL "ORDER BY created DESC"
    if (-not $issues) { return }
    
    $qualityData = @{}
    foreach ($issue in $issues.issues) {
        $project = $issue.fields.project.key
        if (-not $qualityData.ContainsKey($project)) {
            $qualityData[$project] = @{
                "Total" = 0
                "Bugs" = 0
                "HighPriorityBugs" = 0
                "Reopened" = 0
                "TechnicalDebt" = 0
                "IssueTypes" = @{}
                "RootCauses" = @{}
            }
        }
        
        $qualityData[$project].Total++
        if ($issue.fields.issuetype.name -eq "Bug") {
            $qualityData[$project].Bugs++
            if ($issue.fields.priority.name -in @("High", "Highest")) {
                $qualityData[$project].HighPriorityBugs++
            }
        }
        if ($issue.fields.status.name -eq "Reopened") {
            $qualityData[$project].Reopened++
        }
        if ($issue.fields.labels -and $issue.fields.labels -match "technical-debt|refactor|cleanup") {
            $qualityData[$project].TechnicalDebt++
        }
        
        $issueType = $issue.fields.issuetype.name
        if (-not $qualityData[$project].IssueTypes.ContainsKey($issueType)) {
            $qualityData[$project].IssueTypes[$issueType] = 0
        }
        $qualityData[$project].IssueTypes[$issueType]++
    }
    
    foreach ($project in $qualityData.Keys) {
        $data = $qualityData[$project]
        $bugRate = if ($data.Total -gt 0) { ($data.Bugs / $data.Total) * 100 } else { 0 }
        $criticalBugRate = if ($data.Total -gt 0) { ($data.HighPriorityBugs / $data.Total) * 100 } else { 0 }
        $reopenedRate = if ($data.Total -gt 0) { ($data.Reopened / $data.Total) * 100 } else { 0 }
        $debtRate = if ($data.Total -gt 0) { ($data.TechnicalDebt / $data.Total) * 100 } else { 0 }
        
        $recommendations = @()
        
        if ($bugRate -gt 20) {
            $recommendations += "High bug rate ($([math]::Round($bugRate, 1))%) indicates quality issues. Implement stricter code reviews, automated testing, and quality gates."
        }
        
        if ($criticalBugRate -gt 10) {
            $recommendations += "High critical bug rate ($([math]::Round($criticalBugRate, 1))%) suggests serious quality problems. Focus on prevention through better requirements analysis and testing."
        }
        
        if ($reopenedRate -gt 15) {
            $recommendations += "High reopened rate ($([math]::Round($reopenedRate, 1))%) indicates incomplete fixes. Implement better testing and validation processes."
        }
        
        if ($debtRate -gt 25) {
            $recommendations += "High technical debt rate ($([math]::Round($debtRate, 1))%) is impacting productivity. Allocate 20% of sprint capacity to debt reduction."
        }
        
        # Analyze issue type distribution
        $bugPercentage = if ($data.Total -gt 0) { ($data.IssueTypes["Bug"] / $data.Total) * 100 } else { 0 }
        if ($bugPercentage -gt 30) {
            $recommendations += "Bug issues represent $([math]::Round($bugPercentage, 1))% of total issues. Focus on prevention rather than detection."
        }
        
        if ($recommendations.Count -gt 0) {
            $recommendation = $recommendations -join "`n`n"
            Send-Recommendation -Title "Quality Improvement for $project" -Recommendation $recommendation -Impact "High" -Effort "High" -Category "Quality"
        }
    }
}

function Get-ProcessOptimizationRecommendations {
    Write-Host "Generating process optimization recommendations..." -ForegroundColor Cyan
    
    $issues = Get-JiraData -JQL "ORDER BY created DESC"
    if (-not $issues) { return }
    
    $processData = @{
        "Total" = 0
        "StatusTransitions" = @{}
        "LeadTimes" = @()
        "Bottlenecks" = @{}
        "WorkflowEfficiency" = @{}
    }
    
    foreach ($issue in $issues.issues) {
        $processData.Total++
        
        $created = [DateTime]::Parse($issue.fields.created)
        $updated = [DateTime]::Parse($issue.fields.updated)
        $leadTime = ($updated - $created).TotalDays
        $processData.LeadTimes += $leadTime
        
        $status = $issue.fields.status.name
        if (-not $processData.StatusTransitions.ContainsKey($status)) {
            $processData.StatusTransitions[$status] = 0
        }
        $processData.StatusTransitions[$status]++
        
        # Identify bottlenecks
        if ($leadTime -gt 30) {
            $processData.Bottlenecks[$issue.key] = $leadTime
        }
    }
    
    $recommendations = @()
    
    # Analyze lead time distribution
    $avgLeadTime = ($processData.LeadTimes | Measure-Object -Average).Average
    $medianLeadTime = ($processData.LeadTimes | Sort-Object)[[math]::Floor($processData.LeadTimes.Count / 2)]
    $p95LeadTime = ($processData.LeadTimes | Sort-Object)[[math]::Floor($processData.LeadTimes.Count * 0.95)]
    
    if ($avgLeadTime -gt 14) {
        $recommendations += "Average lead time of $([math]::Round($avgLeadTime, 1)) days exceeds recommended 14 days. Implement process improvements to reduce cycle time."
    }
    
    if ($p95LeadTime -gt 60) {
        $recommendations += "95th percentile lead time of $([math]::Round($p95LeadTime, 1)) days indicates significant process bottlenecks. Focus on eliminating long-running issues."
    }
    
    # Analyze status distribution
    $statusCount = $processData.StatusTransitions.Count
    if ($statusCount -gt 10) {
        $recommendations += "Complex workflow with $statusCount statuses may cause confusion. Simplify to 3-5 key statuses."
    }
    
    # Identify most common bottlenecks
    $bottleneckCount = $processData.Bottlenecks.Count
    if ($bottleneckCount -gt $processData.Total * 0.1) {
        $recommendations += "$bottleneckCount issues (10%+) are taking longer than 30 days. Implement escalation procedures and regular reviews."
    }
    
    # Analyze workflow efficiency
    $inProgressCount = if ($processData.StatusTransitions.ContainsKey("In Progress")) { $processData.StatusTransitions["In Progress"] } else { 0 }
    $doneCount = if ($processData.StatusTransitions.ContainsKey("Done")) { $processData.StatusTransitions["Done"] } else { 0 }
    $efficiency = if ($processData.Total -gt 0) { ($doneCount / $processData.Total) * 100 } else { 0 }
    
    if ($efficiency -lt 70) {
        $recommendations += "Low workflow efficiency ($([math]::Round($efficiency, 1))% completion rate). Review and optimize the workflow process."
    }
    
    if ($recommendations.Count -gt 0) {
        $recommendation = $recommendations -join "`n`n"
        Send-Recommendation -Title "Process Optimization Recommendations" -Recommendation $recommendation -Impact "High" -Effort "Medium" -Category "Process"
    }
}

function Get-RiskMitigationRecommendations {
    Write-Host "Generating risk mitigation recommendations..." -ForegroundColor Cyan
    
    $issues = Get-JiraData -JQL "ORDER BY created DESC"
    if (-not $issues) { return }
    
    $riskData = @{}
    foreach ($issue in $issues.issues) {
        $project = $issue.fields.project.key
        if (-not $riskData.ContainsKey($project)) {
            $riskData[$project] = @{
                "Total" = 0
                "Overdue" = 0
                "HighPriority" = 0
                "Unassigned" = 0
                "Blocked" = 0
                "LongRunning" = 0
                "Dependencies" = 0
            }
        }
        
        $riskData[$project].Total++
        
        if ($issue.fields.duedate -and [DateTime]::Parse($issue.fields.duedate) -lt (Get-Date) -and $issue.fields.status.name -ne "Done") {
            $riskData[$project].Overdue++
        }
        if ($issue.fields.priority.name -in @("High", "Highest")) {
            $riskData[$project].HighPriority++
        }
        if (-not $issue.fields.assignee) {
            $riskData[$project].Unassigned++
        }
        if ($issue.fields.status.name -eq "Blocked") {
            $riskData[$project].Blocked++
        }
        
        $created = [DateTime]::Parse($issue.fields.created)
        $daysSinceCreated = (Get-Date) - $created
        if ($daysSinceCreated.TotalDays -gt 30) {
            $riskData[$project].LongRunning++
        }
    }
    
    foreach ($project in $riskData.Keys) {
        $data = $riskData[$project]
        $overdueRate = if ($data.Total -gt 0) { ($data.Overdue / $data.Total) * 100 } else { 0 }
        $unassignedRate = if ($data.Total -gt 0) { ($data.Unassigned / $data.Total) * 100 } else { 0 }
        $blockedRate = if ($data.Total -gt 0) { ($data.Blocked / $data.Total) * 100 } else { 0 }
        $longRunningRate = if ($data.Total -gt 0) { ($data.LongRunning / $data.Total) * 100 } else { 0 }
        
        $riskScore = $overdueRate + $unassignedRate + $blockedRate + $longRunningRate
        
        $recommendations = @()
        
        if ($overdueRate -gt 20) {
            $recommendations += "High overdue rate ($([math]::Round($overdueRate, 1))%) indicates schedule risk. Implement better deadline management and early warning systems."
        }
        
        if ($unassignedRate -gt 15) {
            $recommendations += "High unassigned rate ($([math]::Round($unassignedRate, 1))%) suggests resource allocation issues. Implement automatic assignment or resource planning."
        }
        
        if ($blockedRate -gt 10) {
            $recommendations += "High blocked rate ($([math]::Round($blockedRate, 1))%) indicates dependency issues. Implement dependency tracking and resolution procedures."
        }
        
        if ($longRunningRate -gt 25) {
            $recommendations += "High long-running rate ($([math]::Round($longRunningRate, 1))%) suggests scope creep or estimation issues. Implement regular reviews and scope management."
        }
        
        if ($riskScore -gt 50) {
            $recommendations += "Overall risk score of $([math]::Round($riskScore, 1))% indicates high project risk. Implement comprehensive risk management procedures."
        }
        
        if ($recommendations.Count -gt 0) {
            $recommendation = $recommendations -join "`n`n"
            Send-Recommendation -Title "Risk Mitigation for $project" -Recommendation $recommendation -Impact "Critical" -Effort "High" -Category "Risk"
        }
    }
}

# =============================================================================
# MAIN EXECUTION
# =============================================================================

Write-Host "Jira AI Recommendations Engine" -ForegroundColor Green
Write-Host "==============================" -ForegroundColor Green
Write-Host "Recommendation Type: $RecommendationType" -ForegroundColor Yellow
Write-Host "Priority: $Priority" -ForegroundColor Yellow
Write-Host "Notifications Enabled: $EnableNotifications" -ForegroundColor Yellow
Write-Host "Auto Actions Enabled: $EnableAutoActions" -ForegroundColor Yellow

try {
    switch ($RecommendationType.ToLower()) {
        "performance" {
            Get-PerformanceOptimizationRecommendations
        }
        "resource" {
            Get-ResourceOptimizationRecommendations
        }
        "quality" {
            Get-QualityImprovementRecommendations
        }
        "process" {
            Get-ProcessOptimizationRecommendations
        }
        "risk" {
            Get-RiskMitigationRecommendations
        }
        "all" {
            Get-PerformanceOptimizationRecommendations
            Get-ResourceOptimizationRecommendations
            Get-QualityImprovementRecommendations
            Get-ProcessOptimizationRecommendations
            Get-RiskMitigationRecommendations
        }
        default {
            Write-Warning "Unknown recommendation type: $RecommendationType. Use 'all', 'performance', 'resource', 'quality', 'process', or 'risk'"
        }
    }
    
    Write-Host "AI recommendations generation completed successfully." -ForegroundColor Green
}
catch {
    Write-Error "Error during AI recommendations generation: $($_.Exception.Message)"
}

Write-Host "AI recommendations engine finished." -ForegroundColor Green
